classdef ephys_cell
%This class is designed to hold ephys data from ibw files generated by ecceles
% 
    properties
        name = [];
        sweeps = [];
        summary_data = [];
    end
    
    methods
        function obj = ephys_cell(cell_name, export_path)
            if nargin < 2
                export_path = pwd;
            end
            
            obj.name = cell_name;
            
            ibw_files = dir([cell_name '_*.ibw']);
            
            rawsweeps = [];
            commands = [];
            sweeptime = [];
            DAQ = [];
            kHz = [];
            
            for i=1:length(ibw_files)
                if contains(ibw_files(i).name,'rawsweeps')
                    rawsweeps = IBWread([cell_name '_rawsweeps.ibw']);
                end
                if contains(ibw_files(i).name,'commands')
                    commands = IBWread([cell_name '_commands.ibw']);
                end
                if contains(ibw_files(i).name,'sweeptimes')
                    sweeptimes = IBWread([cell_name '_sweeptimes.ibw']);
                end
                if contains(ibw_files(i).name,'Vm')
                    Vm = IBWread([cell_name '_Vm.ibw']);
                end
                if contains(ibw_files(i).name,'Rin')
                    Rin = IBWread([cell_name '_Rin.ibw']);
                end
                if contains(ibw_files(i).name,'slope')
                    slope = IBWread([cell_name '_slope.ibw']);
                end
                if contains(ibw_files(i).name,'temperature')
                    temperature = IBWread([cell_name '_temperature.ibw']);
                end
                if contains(ibw_files(i).name,'DAQ')
                    DAQ = IBWread([cell_name '_DAQ.ibw']);
                end
                if contains(ibw_files(i).name,'kHz')
                    kHz = IBWread([cell_name '_kHz.ibw']);
                end
            end
            
            if isempty(DAQ) || isempty(kHz)
                kHz = 50000;
                DAQ = 50000;
                num_sweeps = floor(length(rawsweeps.y)./DAQ);
                DAQ.y = ones(1,num_sweeps)*DAQ;
                kHz.y = ones(1,num_sweeps)*kHz;            
            end
            
            for i=1:length(DAQ.y)
                obj.sweeps(i).rawsweep = rawsweeps.y(1+(i-1)*DAQ.y(i):DAQ.y(i)*i);
                obj.sweeps(i).commands = commands.y(1+(i-1)*DAQ.y(i):DAQ.y(i)*i);
                obj.sweeps(i).dVdt = [];
                obj.sweeps(i).time = 0: 1./kHz.y(i) : DAQ.y(i)./kHz.y(i)-1./kHz.y(i);
                obj.sweeps(i).sweeptime = sweeptimes.y(i);
                obj.sweeps(i).DAQ = DAQ.y(i);
                obj.sweeps(i).fs = kHz.y(i);
                obj.sweeps(i).spike_index = [];
                obj.sweeps(i).spike_times = [];
                obj.sweeps(i).spikes = [];
                obj.sweeps(i).Rin = [];
                obj.sweeps(i).Vm = [];
                obj.sweeps(i).sag = [];
                obj.sweeps(i).rebound = [];
            end
            
            for i=1:length(obj.sweeps)
                obj.sweeps(i) = obj.parse_sweep(obj.sweeps(i));
            end
            
            figure;
            hold on;
            for i=1:length(obj.sweeps)
                plot(obj.sweeps(i).time,obj.sweeps(i).rawsweep-obj.sweeps(i).Vm);
            end
            
            disp(['Imported ' cell_name]);
            
            
        end
        
        function sweep = parse_sweep(obj,sweep) 

            sweep = obj.parse_spike(sweep);
            sweep = obj.parse_Rin(sweep);
            sweep = obj.parse_sag_and_rebound(sweep);
            sweep.Vm = mean(sweep.rawsweep(1:.05*50000));

        end
        
        function sweep = parse_sag_and_rebound(obj, sweep)
            
            hyp_commands = find(sweep.commands < 0);
            if isempty(find(diff(hyp_commands) > 1)) &&...
                    length(hyp_commands)./sweep.fs == 120 &&...
                    sweep.commands(hyp_commands(1)) == -400
                baseline_Vm = sweep.rawsweep(hyp_commands(1)-1);
                steadystate_Vm = sweep.rawsweep(hyp_commands(end));
                sweep.sag = steadystate_Vm-min(sweep.rawsweep(hyp_commands));
                sweep.rebound = max(sweep.rawsweep(hyp_commands(end):hyp_commands(end)+.2*sweep.fs)) - baseline_Vm;
            end
        end
        
        function sweep = parse_Rin(obj,sweep)
            
            hyp_commands = find(sweep.commands < 0);
            
            if isempty(find(diff(hyp_commands) > 1)) &&...
                    length(hyp_commands)./sweep.fs == 120 &&...
                    sweep.commands(hyp_commands(1)) == -50
                dVm = (sweep.rawsweep(hyp_commands(1)-1) - sweep.rawsweep(hyp_commands(end))).*10.^-3;
                dI = (sweep.commands(hyp_commands(1)-1) - sweep.commands(hyp_commands(end))).*10.^-12;              
                sweep.Rin = (dVm./dI) ./10^6  ;
            else
                sweep.Rin = NaN;                
            end                        
        end
          
        function sweep = parse_spike(obj, sweep)
            
            spikes = [];
            
            sweep.dVdt = gradient(sweep.rawsweep)./gradient(sweep.time);
            
            for i=2:length(sweep.dVdt)-10 %find spike starts
                 if sweep.dVdt(i-1) < 15 && all(sweep.dVdt(i:i+10) >= 15)
                     sweep.spike_index = [sweep.spike_index, i];
                     sweep.spike_times = [sweep.spike_times sweep.time(i)];
                     
                     spike = [];
                     spike.start_index = i;
                     spike.start_time = sweep.time(i);
                     
                     for j=i:length(sweep.dVdt)
                         if sweep.dVdt(j-1) < 0 && sweep.dVdt(j)>= 0
                             spike.end_index = j;
                             spike.end_time = sweep.time(j);
                             spike.AP_threshold = sweep.rawsweep(i);
                             spike.AP_max = max(sweep.rawsweep(spike.start_index:spike.end_index));
                             spike.dVdt_max = max(sweep.dVdt(spike.start_index:spike.end_index));
                             spike.AP_height = spike.AP_max-spike.AP_threshold;
                             top_half = find(sweep.rawsweep(spike.start_index:spike.end_index) >= spike.AP_max-spike.AP_height./2);                           
                             spike.AP_width = sweep.time(top_half(end))-sweep.time(top_half(1));
                             break;
                         end  
                     end
                     sweep.spikes = [sweep.spikes spike];
                 end
             end
            

        end
    end
end
    


